<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Web Cache Poisoning</title>
  <link rel="stylesheet" href="/static/style.css">
</head>
<body>
<header id="title-block-header">
</header>
<h1 id="web-cache-poisoning">Web Cache Poisoning</h1>
<h2 id="summary">Summary</h2>
<ul>
<li><p><a href="#recon">Recon for Web Cache Poisoning</a></p></li>
<li><p><a href="#cheat-sheet">Portswigger Labs Cheat Sheet /
Payloads</a></p></li>
<li><p>Additional Note: There is a PDF attached in this folder that has
a walk-through of the labs. The document does not need to be downloaded,
it can be viewed inline in GitHub.</p></li>
</ul>
<p><br><br></p>
<h2 id="recon">Recon</h2>
<ul>
<li><p>https://portswigger.net/web-security/web-cache-poisoning#constructing-a-web-cache-poisoning-attack</p></li>
<li><p>https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws#cache-probing-methodology</p></li>
</ul>
<p><br><br></p>
<h2 id="tools-and-burp-extensions-used">Tools and Burp Extensions
Used</h2>
<ul>
<li><p>Param Miner Extension</p>
<ul>
<li><p>https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943</p></li>
<li><p>https://portswigger.net/burp/documentation/desktop/testing-workflow/analyzing/hidden-inputs</p></li>
</ul></li>
<li><p>Using the Bup Scanner to perform a targeted scan on a request
also helped to identify web cache poisoning.</p></li>
</ul>
<p><br><br></p>
<h2 id="cheat-sheet">Cheat Sheet</h2>
<h3 id="section-exploiting-cache-design-flaws"><strong>Section:
Exploiting cache design flaws</strong></h3>
<p><br><br></p>
<h3 id="web-cache-poisoning-with-an-unkeyed-header"><strong>Web cache
poisoning with an unkeyed header</strong></h3>
<ul>
<li><p>Identify an unkeyed header that the application is using to
dynamically build content in the response. Depending on how the
application is using this data, several different attacks are possible
such as XSS or open redirection.</p></li>
<li><p>The Burp Extension Param Miner can help to identify unkeyed
headers/parameters. Either way ensure that a “cache buster” is included
in the testing payloads to prevent the test payloads from being cached
for normal application request.</p></li>
<li><p>Usually headers like X-Forwarded-Host are used to dynamically
generate some content on the server’s response such as domains for
JavaScript files. We can use the Exploit Server in the labs to host the
same file location with malicious JavaScript payload, then poison the
cache so that the response points to the Exploit Server’s
domain.</p></li>
<li><p>Exploit Server Payload:</p>
<ul>
<li><p>File: This should be the same path as the script location in
application’s response. Example: /resources/js/tracking.js</p></li>
<li><p>Body: Include an XSS payload in there.</p></li>
</ul></li>
<li><p>Example:</p>
<ul>
<li><p>Application’s standard “cache keyed” header:</p>
<ul>
<li>Host: Lab-Domain.net</li>
</ul></li>
<li><p>Application using “unkeyed” header to dynamically generate JS
links:</p>
<ul>
<li>X-Forwarded-Host: Exploit-Server.net</li>
</ul></li>
</ul></li>
<li><p>Since the X-Forwarded-Host header is not part of the cache key,
the malicious cached response will be served to all users submitting the
normal HTTP request (which does not require this header to be
sent).</p></li>
</ul>
<p><br><br></p>
<h3 id="web-cache-poisoning-with-an-unkeyed-cookie"><strong>Web cache
poisoning with an unkeyed cookie</strong></h3>
<ul>
<li><p>Identify if there are any unkeyed cookies in the request that the
application is using in an unsafe way in the response.</p></li>
<li><p>In a scenario where the application is taking the value of the
cookie and including it within the HTML in the response, try injecting
an XSS payload that will break out of the context and successfully
executes.</p></li>
<li><p>Use a cache buster while testing for cache poisoning. If the
response to the request is cached send a “normal” request to
confirm.</p></li>
<li><p>Vulnerability Example:</p></li>
</ul>
<div class="sourceCode" id="cb1"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>script<span class="op">&gt;</span> data <span class="op">=</span> { <span class="st">&quot;data&quot;</span><span class="op">:</span><span class="st">&quot;user-input&quot;</span> } <span class="op">&lt;/</span>script<span class="op">&gt;</span></span></code></pre></div>
<ul>
<li>Injected Payload:</li>
</ul>
<div class="sourceCode" id="cb2"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;}&lt;/script&gt;&lt;img src=x onerror=alert(1)&gt;//</span></span></code></pre></div>
<p><br><br></p>
<h3 id="web-cache-poisoning-with-multiple-headers"><strong>Web cache
poisoning with multiple headers</strong></h3>
<ul>
<li><p>Sometimes it takes manipulating multiple unkeyed headers in a
request in order to get the application to use the input in an unsafe
way.</p></li>
<li><p>If the application redirects an HTTP request to HTTPs for any
request that is sent to the application, check the following
headers:</p>
<ul>
<li><p>X-Forwarded-Host: example.com</p></li>
<li><p>X-Forwarded-Scheme: http</p></li>
</ul></li>
<li><p>The application will redirect the request to HTTPs and will use
the value in the X-Forwarded-Host header as the domain in the Location
response HTTP header.</p>
<ul>
<li>Example: Location:
https://example.com/{whatever-path-was-in-the-request-line}</li>
</ul></li>
<li><p>If there is a JavaScript file endpoint in the application, this
request can be poisoned so that the application grabs the malicious code
from the Exploit Server. The reason we want to use a JavaScript file
endpoint, is because the requests to these files are typically
automatically triggered as soon as the user loads the application and
the Exploit Server can be used to host malicious code using the same
file path.</p>
<ul>
<li><p>Example: In the Exploit Server, we’ll create the same file path
so the application functions properly and inject malicious code from our
server.</p>
<ul>
<li><p>Normal path in app: -&gt; lab-domain.net/lab/source.js</p></li>
<li><p>Use same path in exploit server: -&gt;
exploit-server.net/lab/source.js</p></li>
</ul></li>
</ul></li>
</ul>
<p><br><br></p>
<h3
id="targeted-web-cache-poisoning-using-an-unknown-header"><strong>Targeted
web cache poisoning using an unknown header</strong></h3>
<ul>
<li><p>Use Burp Extension Param Miner to identify any arbitrary unkeyed
headers.</p></li>
<li><p>Scenario:</p></li>
<li><p>The application is using the value of an unkeyed header inside of
a “src” attribute in a &lt;script&gt; tag, as the domain value.</p></li>
<li><p>The application’s response includes the header: Vary:
User-Agent</p></li>
<li><p>This means that the application is using the User-Agent header as
a keyed header and based on the value of it, will return different
responses. For example, mobile users vs desktop users may have different
User-Agents and a different response will be served.</p></li>
<li><p>In order to figure out a user’s User-Agent value that is most
visited in the application, find an XSS vulnerability in the application
and include a payload that will reach out to the Exploit Server, then
review the logs to determine the victim user’s User Agent value:</p>
<ul>
<li>Example:</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb3"><pre
class="sourceCode html"><code class="sourceCode html"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">img</span><span class="ot"> src</span><span class="op">=</span><span class="st">&quot;https://exploit-server&quot;</span><span class="ot"> </span><span class="dt">/&gt;</span></span></code></pre></div>
<ul>
<li><p>Once the User-Agent is grabbed from the logs for a victim user
that was attacked with the XSS, use the following headers to poison the
cache for example. Note: The X-Host header was identified by the Param
Miner extension:</p>
<ul>
<li><p>X-Host: example.com</p></li>
<li><p>User-Agent: victim-user’s-value</p></li>
</ul></li>
<li><p>Because the User-Agent header is “keyed”, whenever a user with
that same User-Agent makes a request to the application, the malicious
response will be served back to them.</p></li>
<li><p>Use the Exploit Server to host malicious XSS payload using the
same file path as the “X-Host” is being injected to.</p></li>
</ul>
<p><br><br></p>
<h3
id="web-cache-poisoning-to-exploit-a-dom-vulnerability-via-a-cache-with-strict-cacheability-criteria"><strong>Web
cache poisoning to exploit a DOM vulnerability via a cache with strict
cacheability criteria</strong></h3>
<ul>
<li>View the lab/document details. -
https://portswigger.net/web-security/web-cache-poisoning/exploiting-design-flaws/lab-web-cache-poisoning-to-exploit-a-dom-vulnerability-via-a-cache-with-strict-cacheability-criteria</li>
</ul>
<p><br><br><br></p>
<h3 id="section-exploiting-cache-implementation-flaws"><strong>Section:
Exploiting cache implementation flaws</strong></h3>
<p><br><br></p>
<h3 id="web-cache-poisoning-via-an-unkeyed-query-string"><strong>Web
cache poisoning via an unkeyed query string</strong></h3>
<ul>
<li><p>An arbitrary query parameter is unkeyed. Usually, any values in
the request line are keyed, however many websites and CDNs perform
various transformations on keyed components when they are saved in the
cache key, such as removing query parameters/strings.</p>
<ul>
<li>Example: The query parameter is dynamically included in the HTML
response - ?test=123</li>
</ul></li>
<li><p>Inject an XSS payload in the parameter and since it is an unkeyed
parameter, the cache will be poisoned with the malicious
response.</p></li>
<li><p>Verify that the parameter is not part of the cache key by
removing it and sending the request, if the response still contains the
parameter’s data we know that it was cached and not part of the cache
key.</p></li>
<li><p>Use Param Miner to help identify unkeyed parameters:</p>
<ul>
<li>Extensions -&gt; Param Miner -&gt; Param Miner -&gt; Unkeyed
param</li>
</ul></li>
</ul>
<p><br><br></p>
<h3 id="web-cache-poisoning-via-an-unkeyed-query-parameter"><strong>Web
cache poisoning via an unkeyed query parameter</strong></h3>
<ul>
<li><p>Sometimes only specific query parameters are unkeyed and to
discover them requires fuzzing for unkeyed parameters.</p></li>
<li><p>For example, the “utm_content” parameter is unkeyed and the
application is using the data in an unsafe way in the HTTP response.
This vector can be used to perform an XSS attack. Use a valid XSS
payload that breaks out of the current context so that it successfully
executes.</p></li>
<li><p>Param Miner can help identify these headers. Extensions -&gt;
Param Miner -&gt; Guess params -&gt; Guess GET Parameters</p></li>
<li><p>Use the following header in the request to potential gain access
to the cache key:</p>
<ul>
<li>Pragma: x-get-cache-key</li>
</ul></li>
</ul>
<p><br><br></p>
<h3 id="parameter-cloaking"><strong>Parameter cloaking</strong></h3>
<ul>
<li><p>This concept takes advantage of the parsing discrepancies between
the cache and the application. Identify an excluded parameter from the
cache by using the Burp scanner or Param Miner extension.</p></li>
<li><p>Below are some examples to exploit these discrepancies:</p></li>
<li><p>Cache identifies 2 parameters here, and excludes the 2nd one from
the cache key.</p></li>
<li><p>Application identifies only 1 parameter here, so the entire
String is processed. Identify if this String/value is passed to useful
gadget.</p></li>
</ul>
<pre><code>GET /?example=123?excluded_param=bad-stuff-here</code></pre>
<p><br></p>
<ul>
<li><p>Cache identifies 2 parameters here and will remove the
“excluded_param” and everything after from the cache key.</p></li>
<li><p>Application however see’s 3 parameters and will process the last
“keyed_param”. Identify if this String/value is passed to useful
gadget.</p></li>
</ul>
<pre><code>GET /?keyed_param=abc&amp;excluded_param=123;keyed_param=bad-stuff-here</code></pre>
<ul>
<li><p>Review this concept using the lab material and document.</p></li>
<li><p>Link:
https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws#cache-parameter-cloaking</p></li>
<li><p>The exploitation for this was using a request for some .js file,
keep that in mind.</p></li>
</ul>
<p><br><br></p>
<h3 id="web-cache-poisoning-via-a-fat-get-request"><strong>Web cache
poisoning via a fat GET request</strong></h3>
<ul>
<li><p>The application is using a query parameter in an unsafe way in
the HTTP response; however, this query parameter is keyed.</p></li>
<li><p>Try including the same parameter in the body of the GET request =
FAT GET Request</p></li>
<li><p>The application may grab the value of the body parameter, and
since the “body” parameter is not part of the cache key, the cache will
be poisoned with malicious data.</p></li>
<li><p>Example:</p>
<ul>
<li><p>URL query parameter part of the cache key: ?test=123</p></li>
<li><p>Body parameter NOT part of the cache key: test=123</p></li>
</ul></li>
<li><p>The exploitation for this was using a request for some .js file,
keep that in mind.</p></li>
<li><p>In order for this technique to work, the application must accept
GET requests that contain a body. However below is a work around to
override the HTTP method:</p></li>
</ul>
<pre><code>GET /?param=innocent HTTP/1.1
Host: innocent-website.com
X-HTTP-Method-Override: POST
…
param=bad-stuff-here</code></pre>
<p><br><br></p>
<h3 id="url-normalization"><strong>URL normalization</strong></h3>
<ul>
<li><p>Browsers usually automatically encode special characters in the
URL. If the application is reflecting the URL within an HTML context,
this can be a vector for XSS. However, since the application is not
decoding the URL, the payload will not execute, as it will still be in
its encoded form.</p></li>
<li><p>However, this can be bypassed using Burp Suite directly to send
the XSS payload in the URL. If the application is caching this response,
then sending this URL to victim users will still cause the browser to
encode the URL, but after URL normalization the malicious cached
response will be served to the victim user. Basically the 2 requests
will be treated as the same cache key, so the malicious response will be
returned.</p></li>
<li><p>This is a vector that is usually not exploitable by itself since
the browsers URL encode the data and the application doesn’t decode it.
But with cache poisoning it can be exploited.</p></li>
<li><p>Basically sending the following payload through Burp Suite, will
cause the application to reflect the unencoded payload which will be
executed and also cached:</p></li>
</ul>
<pre><code>GET /&lt;script&gt;alert(1)&lt;/script&gt;</code></pre>
<p><br><br><br></p>
<h3
id="pending-to-complete-labs-that-are-missing-from-this-cheat-sheet">Pending
to complete labs that are missing from this cheat sheet</h3>
<ul>
<li><p>LAB EXPERT Combining web cache poisoning vulnerabilities</p></li>
<li><p>LAB EXPERT Cache key injection</p></li>
<li><p>LAB EXPERT Internal cache poisoning</p></li>
</ul>
</body>
</html>
