<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>HTTP Host Header Attacks</title>
  <link rel="stylesheet" href="/static/style.css">
</head>
<body>
<header id="title-block-header">
</header>
<h1 id="http-host-header-attacks">HTTP Host Header Attacks</h1>
<h2 id="summary">Summary</h2>
<ul>
<li><p><a href="#recon">Recon for HTTP Host Header Attacks</a></p></li>
<li><p><a href="#cheat-sheet">Portswigger Labs Cheat Sheet /
Payloads</a></p></li>
<li><p>Additional Note: There is a PDF attached in this folder that has
a walk-through of the labs. The document does not need to be downloaded,
it can be viewed inline in GitHub.</p></li>
</ul>
<p><br><br></p>
<h2 id="recon">Recon</h2>
<h3
id="check-out-these-pages-for-how-to-test-for-vulnerabilities-in-host-header-and-different-validation-bypass-techniques"><strong>Check
out these pages for how to test for vulnerabilities in Host header and
different validation bypass techniques:</strong></h3>
<ul>
<li><p>https://portswigger.net/web-security/host-header/exploiting#how-to-test-for-vulnerabilities-using-the-http-host-header</p></li>
<li><p>https://portswigger.net/web-security/ssrf#circumventing-common-ssrf-defenses</p></li>
<li><p>https://portswigger.net/web-security/cors#errors-parsing-origin-headers</p></li>
</ul>
<p><br></p>
<ul>
<li><p>Overview:</p>
<ul>
<li><p>To test whether a website is vulnerable to attack via the HTTP
Host header, you will need an intercepting proxy, such as Burp Proxy,
and manual testing tools like Burp Repeater and Burp Intruder.</p></li>
<li><p>Important: In short, you need to identify whether you are able to
modify the Host header and still reach the target application with your
request. If so, you can use this header to probe the application and
observe what effect this has on the response.</p></li>
<li><p>Burp Suite accurately maintains the separation between the Host
header and the target IP address. This separation allows you to supply
any arbitrary or malformed Host header that you want, while still making
sure that the request is sent to the intended target.</p></li>
</ul></li>
</ul>
<p><br><br></p>
<h2 id="cheat-sheet">Cheat Sheet</h2>
<p><br></p>
<h3 id="basic-password-reset-poisoning"><strong>Basic password reset
poisoning</strong></h3>
<ul>
<li><p>If the application exposes a password reset functionality,
determine how the application is generating the password reset URL. It
may be possible to inject a malicious domain in that URL by manipulating
the Host header or including other headers such as
X-Forwarded-Host.</p></li>
<li><p>In the labs, use the Exploit Server’s email client to test the
functionality and see if the domain is dynamically generated by user
controllable input.</p></li>
<li><p>Example:</p>
<ul>
<li>Host: Exploit-Server.net</li>
</ul></li>
</ul>
<p><br><br></p>
<h3 id="web-cache-poisoning-via-ambiguous-requests"><strong>Web cache
poisoning via ambiguous requests</strong></h3>
<ul>
<li><p>When probing for potential Host header attacks, you will often
come across seemingly vulnerable behavior that isn’t directly
exploitable. For example, you may find that the Host header is reflected
in the response markup without HTML-encoding, or even used directly in
script imports. Reflected, client-side vulnerabilities, such as XSS, are
typically not exploitable when they’re caused by the Host header. There
is no way for an attacker to force a victim’s browser to issue an
incorrect host in a useful manner.</p></li>
<li><p>Using Burp Suite, add another Host header in the HTTP request
with an arbitrary value and identify if the application is using the
value in the HTTP responses in an unsafe way.</p></li>
<li><p>Example:</p>
<ul>
<li><p>Host: test</p></li>
<li><p>Host: normal-host</p></li>
</ul></li>
<li><p>Host headers are typically not part of the cache key, so if the
application is using a web cache and the malicious payload is cached in
the HTTP response, the malicious payload will still reach other user’s
normal HTP requests.</p></li>
<li><p>Example:</p></li>
<li><p>The application is grabbing the value from the additional Host
header and dynamically generating a JavaScript source file. Use the
lab’s Exploit Server to host malicious content using the same file
path/endpoint. Then poison the cache with the Exploit Server’s domain
using the Host header. Ensure the “Content-Type” header has the correct
mime type.</p></li>
<li><p>https://user-controllable-domain/resources/file.js - ensure that
in the Exploit Server the payload is under the same path
(/resources/file.js)</p></li>
</ul>
<p><br><br></p>
<h3 id="host-header-authentication-bypass"><strong>Host header
authentication bypass</strong></h3>
<ul>
<li><p>If the /admin endpoint is only available to users on the
localhost network, we can try injecting the local host values like so
with either of these headers:</p>
<ul>
<li><p>Host: localhost</p></li>
<li><p>X-Forwarded-Host: localhost</p></li>
</ul></li>
<li><p>If that does not work try to encode/obfuscate the header’s value
or add double Host headers.</p></li>
</ul>
<p><br><br></p>
<h3 id="routing-based-ssrf"><strong>Routing-based SSRF</strong></h3>
<ul>
<li><p>The host headers can be used to perform a SSRF attack.</p></li>
<li><p>Replace the original Host header value with another domain and
determine if the application initiates a request to the domain. Burp
Collaborator can be used here for testing.</p></li>
<li><p>If this works, then it means the application is vulnerable to
SSRF through the Host header.</p></li>
<li><p>It is required to use Burp Suite, since the tool accurately
maintains the separation between the Host header and the target IP
address.</p></li>
<li><p>This can be used to access the /admin panel of the application,
as the SSRF payload will target an internal IP address. Use Burp
Intruder to brute force if needed.:</p></li>
<li><p>Example:</p>
<ul>
<li><p>GET /admin HTTP/2</p></li>
<li><p>Host: 192.168.0.2</p></li>
</ul></li>
</ul>
<p><br><br></p>
<h3 id="ssrf-via-flawed-request-parsing"><strong>SSRF via flawed request
parsing</strong></h3>
<ul>
<li><p>The host headers can be used to perform a SSRF attack.</p></li>
<li><p>Replace the original Host header value with another domain and
determine if the application initiates a request to the domain. Burp
Collaborator can be used here for testing.</p></li>
<li><p>If this does not work, then use an additional Host header or the
X-Forwarded-Host header, for example.</p></li>
<li><p>Another technique to try is to supply an absolute URL in the
request line:</p>
<ul>
<li><p>GET https://vulnerable-website.com/admin HTTP/2</p></li>
<li><p>Host: bad-stuff-here - 192.168.0.1</p></li>
</ul></li>
<li><p>If this works, then it means the application is vulnerable to
SSRF through the Host header, while injecting the absolute URL of the
application in the request line.</p></li>
</ul>
<p><br><br></p>
<h3 id="host-validation-bypass-via-connection-state-attack"><strong>Host
validation bypass via connection state attack</strong></h3>
<ul>
<li><p>Poorly implemented HTTP servers sometimes work on the dangerous
assumption that certain properties, such as the Host header, are
identical for all HTTP/1.1 requests sent over the same
connection.</p></li>
<li><p>For example, you may occasionally encounter servers that only
perform thorough validation on the first request they receive over a new
connection. In this case, you can potentially bypass this validation by
sending an innocent-looking initial request then following up with your
malicious one down the same connection.</p></li>
<li><p>To attack the application using the connection state
attack.</p></li>
<li><p>Use Burp Repeater and place 2 different tabs into a new group,
then change the send mode to “Send group in sequence (single
connection)”.</p></li>
<li><p>Ensure the first tab contains the normal HTTP request. The second
tab can contain the malicious HTTP request. Same techniques as previous
examples, can be used here.</p></li>
</ul>
<p><br><br></p>
<h3
id="pending-to-complete-labs-that-are-missing-from-cheat-sheet">Pending
to complete labs that are missing from cheat sheet:</h3>
<ul>
<li>LAB EXPERT Password reset poisoning via dangling markup</li>
</ul>
</body>
</html>
